---
title: "Lab#SE04-1: healthyFood Restaurant, Core Model"
subtitle: "Java SE Lab 04 part 1"
author: albertprofe
date: "06/01/2021"
date-modified: last-modified
date-format: full
description: "Java SE Lab 04, part 1 work on the Core-Model"
categories: [javase, lab, composition, model]
toc: true
number-sections: true
format:
  html
---




::: {.labs}
ðŸ“˜ **Linux Lab#SE04-1: healthyFood Restaurant**

1. Create a Maven/Gradle `Java SE Project`. 
    
    - Crete from [wizard](/javase/se-concepts-createproject.qmd) the Maven Java SE Project and then work with [git](/javase/se-concepts-projectgit.qmd) version control, local and remote (GitHub.com).

2. Add the needed dependencies:

    - Lombok
    - Junit
    - Java Faker

3. Create three `Java` classes to define the **Model**. Java SE Classes:

    - Core Model: Table, Order and Menu
    - Managers and Controller: use a fake DataBase like `ArrayList` or `HashMaps`

4. With `Junit` dependency create **unitary test** to test objects and operations, and then **integration tests**.

5. From here you should add new features **once all the test are passed.**

    - Operations, you could think in a Manager Class o similar
    - New fields/attributes and new classes
    - New compositions and inherence: expand your model
    - Use Factory design pattern to create new objects

Project Overview

- **Technology Stack:**
  - Front-End: React
  - Back-End: Spring Boot

- **System Design:**
  - The UML diagram, designed as part of Lab#SE04-1, lays the groundwork for essential entities such as Orders, Tables, and Menus.

Integration with Spring Boot with API Rest

This Java Maven SE backe-end seamlessly integrates with the React front-end via API Rest, creating a efficient restaurant management.

<mark>The UML design acts as a guide, ensuring a cohesive flow between the front-end and back-end components.</mark>

- [Lab#SE06-1](/reactjs/rjslab6-1.qmd)


:::

---

# General approach

<mark>Welcome to our Java SE project, where we code a culinary app from a quaint little van restaurant to a thriving establishment with over 100 employees. Our approach is simple yet ambitious: **start small, dream big**.</mark>

- In the initial phase, our focus is on building the core structure of our restaurant management system. At the heart of our project, we will design a **Unified Modeling Language (UML) that includes essential classes such as Orders, Tables, and Menus.** 
  - These classes will form the <mark>backbone of our application</mark>, facilitating efficient management of customer orders, table assignments, and menu items.
- To orchestrate the flow of our restaurant operations, we introduce a **Controller class that acts as the central hub for handling user interactions and managing the overall system logic**.
- To simulate a real-world database without the complexities of a full-fledged database system, **we implement a DataBase class utilizing HashMaps.** 
  - This enables us to <mark>store and retrieve crucial information seamlessly, ensuring the smooth functioning of our restaurant.</mark>
- For user interaction, we incorporate an **Input/Output (I/O) class that leverages the Command Line Interface (CLI)**.
  - This ensures a user-friendly and interactive experience, allowing customers and restaurant staff to engage effortlessly with the application.
- To guarantee the reliability and functionality of our codebase, we integrate **JUnit for testing**.
  - This not only validates the correctness of our code but also ensures that any future modifications maintain the integrity of our system.
  - Additionally, we incorporate **Java Faker to generate realistic test data**, saving time and effort in the testing phase.
- Simplifying development and enhancing code readability, we include **Lombok** as a dependency.
  - Lombok streamlines the <mark>creation of boilerplate code</mark>, enabling us to focus on the core functionality of our application.
- Lastly, to manage project dependencies and facilitate easy builds, we structure our project as a **Maven project**.
  - <mark>Maven simplifies the build process<mark>, making it more efficient and maintaining a clean and organized codebase.

::: {.callout-note}

As we embark on this Java SE project, our journey begins with simplicity, but the vision is grand.

We aim **to transform a humble van restaurant with one person and five tables into a bustling establishment with over 100 employees**, embracing scalability and innovation every step of the way.

Get ready to witness the evolution of our restaurant management system from a small-scale dream to a thriving reality.
:::

# Core classes and dependencies

## EcoSystem: tech stack, system design and architecture


(1) Software Core tools: framework/engine/publishing system, Code language, SDK (software development kit)
(2) Development tools: Configuration system and format (.xml, .json, .yml ), Dependencies & packages management
(3) Developer tools: IDE, debugger, collaborative & version control, documentation (Mermaid UML)
(4) DevOps & App LifeCycle: test, deployment, OS, agile management

::: {.column-page-right}
| (1) Software Core tools | (2) Development tools | (3) Developer tools | (4) DevOps |
| -- | -- | -- | -- |
|   |    |   |   |
:::


## Dependencies `pom.xml`

<mark>The `pom.xml` file in a Java SE Maven project is crucial as it serves as the Project Object Model configuration.</mark>

::: {.column-margin}
The `pom.xml` and dependencies enhance project maintainability, collaboration, and adherence to best practices, making them indispensable components for Java developers leveraging Maven for efficient project management and streamlined workflows.
:::

It defines project **metadata, dependencies, plugins, and build configurations, ensuring consistent builds**. Dependencies are vital as they specify external libraries required for the project, facilitating easy management and version control. Maven leverages these elements to automate project builds, simplifying development, testing, and deployment.



## Dependency: Lombok

Use ``Lombok``, [link](https://projectlombok.org/){.external}:

- The **@Data** annotation is a ``Lombok`` annotation that generates getters and setters for the fields of a class, as well as equals, hashCode, and toString methods based on the fields.

- The **@AllArgsConstructor** annotation is a ``Lombok`` annotation that generates a constructor with all of the class's fields as arguments.

- The **@NoArgsConstructor** annotation is a ``Lombok`` annotation that generates a no-argument constructor for a class.

[**@Data**](https://projectlombok.org/features/Data){.external} All together now: A shortcut for **@ToString**, **@EqualsAndHashCode**, **@Getter** on all fields, **@Setter** on all non-final fields, and **@RequiredArgsConstructor**.

Adding lombok to your pom file: to include lombok as a provided dependency, add it to your <dependencies>In your Java code: block like so:

``` {.java .code-overflow-wrap filename="pom.xml"}
<dependencies>
	<dependency>
		<groupId>org.projectlombok</groupId>
		<artifactId>lombok</artifactId>
		<version>1.18.24</version>
		<scope>provided</scope>
	</dependency>
</dependencies>
```
::: {.callout-important}
The version `<version>1.18.24</version>` crashes. Use **1.18.30**
:::


You could then use these classes as follows:



``` {.java .code-overflow-wrap filename="table.java"}
import lombok.Data;

@Data

// define your class
```

### Dependency: Java Faker

Use [Java Faker](https://github.com/DiUS/java-faker){.external}:

In `pom.xml`, add the following xml **dependency** between <dependencies> ... </dependencies>

```{.java .code-overflow-wrap filename="pom.xml"}
<dependencies>
  <dependency>
      <groupId>com.github.javafaker</groupId>
      <artifactId>javafaker</artifactId>
      <version>1.0.2</version>
  </dependency>
</dependencies>
```
In your Java code:

``` {.java .code-overflow-wrap filename="testfaker.java"}
import com.github.javafaker.Faker;
import org.junit.jupiter.api.Test;

Faker faker = new Faker();

String name = faker.name().fullName(); // Miss Samanta Schmidt
String firstName = faker.name().firstName(); // Emory
String lastName = faker.name().lastName(); // Barton

String streetAddress = faker.address().streetAddress(); // 60018 Sawayn Brooks Suite 449
```

### Dependency: JUnit 5

To configure support for **JUnit Jupiter based tests**, configure test scoped dependencies on the [JUnit Jupiter API and the JUnit Jupiter TestEngine](https://junit.org/junit5/docs/current/user-guide/#running-tests-build-maven-engines-configure){.external} implementation similar to the following.

more on [Java SE TDD](/javase/se-concepts-tdd.qmd)

```{.java .code-overflow-wrap filename="pom.xml"}
<!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine -->
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <version>5.9.1</version>
      <scope>test</scope>
    </dependency>
```


## Core classes: table, order and menu

### Solving discussion: UMLs

``` {mermaid}

classDiagram



class Table{

  +String name
  +String description
  +int qty

}

class Order{

  +date date
  +String orderNumber
  +String waiter
  +int peopleqty
  +int totalPayment
  +bool paid
  +Table table
  +Menu[] menus

}

class Menu{

  +String name
  +String price
  +int price
  +string conntent

}

  Table "1" --* "n" Order
  Menu "1" --* "n" Order

```



# Core user-case mockup CLI


```bash
Welcome to healtyFood Mananger v0.0
Table number?
2
People?
6
Menu qty?
3
Menu #1?
5
Menu #2?
3
Menu #3?
5
Total to pay: 80â‚¬ (3 items)
Paid?
true
```

# Fake DataBase: HashMaps

To start and test our UML we are goint to use HashMaps as a fake database.

![](/images/javase/hashmap-orders.jpg)

``` java
HashMap<String, Order> orders
 = new HashMap<String, Order>();

```
::: {.column-margin}
Keep in mind that in more recent versions of Java, you can use the diamond operator (<>) to infer the generic types, making the declaration more concise:

`HashMap<String, Order> orders = new HashMap<>();`

:::

Here's what each part of the code means:

- `HashMap<String, Order>`: This declares a new `HashMap` with keys of type `String` and values of type `Order`. In other words, it's a mapping from strings to `Order` objects.

- `orders`: This is the name of the variable that will reference the `HashMap`. You can choose any valid identifier as the variable name.

- `= new HashMap<String, Order>();`: This part of the code creates a new instance of `HashMap` and assigns it to the variable `orders`. The `new` keyword is used to allocate memory for the `HashMap`, and the `<>` syntax specifies the types of keys and values for the `HashMap`. In this case, keys are of type `String`, and values are of type `Order`.



## References

- [Java HashMap](https://www.w3schools.com/java/java_hashmap.asp)
- [HashMap (Java Platform SE 8 )](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)
- [Java HashMap (With Examples)](https://www.programiz.com/java-programming/hashmap)
- [What is a Java Hashmap?](https://www.freecodecamp.org/news/what-is-a-java-hashmap/)

## Definition

In Java, you use a HashMap to store items in **key/value pairs**. You can access items stored in a `HashMap` using the item's key, which is unique for each item.

## What Are the Features of a HashMap in Java?

Before working with HashMaps, it is important to understand how they work.

Here are some of the features of a `HashMap`:

- Items are stored in **key/value pairs.**
- Items do not maintain **any order when added.** The data is unordered.
- In a case where there are duplicate keys, the last one will override the other(s).
- Data types are specified using **wrapper classes instead of primitive data types.**

## How to Create a HashMap in Java

In order to create and use a HashMap, you must first import the `java.util.HashMap` package. That is:

```java
import java.util.HashMap;
```

Here's what the syntax looks like for creating a new `HashMap`:

```java
HashMap<KeyDataType, ValueDataType> HashMapName = new HashMap<>();
```

## Example

Create a `HashMap` object called **capitalCities** that will store `String` **keys** and `String` **values**:

```java
import java.util.HashMap; // import the HashMap class

HashMap<String, String> capitalCities = new HashMap<String, String>();
```

Create a `HashMap` object called **capitalCities** that will store `String` **keys** and `String` **values**:

```java
import java.util.HashMap; // import the HashMap class

HashMap<String, String> capitalCities = new HashMap<String, String>();javase/selab4-1.qmdjavase/selab4-1.qmd
```


# View: user menus and I/O

to-do

# Business Logic & Controller

to-do

# Code


| Code Version | Commit | Folder-Tree | Output |
| -- | -- | -- | -- |
| [GitHub code v0.0](https://github.com/AlbertProfe/hello11/tree/59000f69fc5ab0d42390c3a9f8a28f0b55cc48c3){.external}  | create project, core UML classes and fast-test Hashmaps in main| [Basic Structure](/images/javase/restaurant-tree-folder-v0.0.png){width="80%"} |[output v0.0 cli](/images/javase/ouputs/output-labse04-1-v0-0.pdf) |
| [GitHub code v0.0 - testFaker](https://github.com/AlbertProfe/hello11/tree/51496acc2d4e3ef0ab87529d21238fb2244612cd){.external}  |  test new dependencies: JUnit, javaFaker, lombok  | - |  [Check version dependencies](https://github.com/AlbertProfe/hello11/blob/51496acc2d4e3ef0ab87529d21238fb2244612cd/pom.xml#L21){.external}  |



<!--- navLinks -->
<br><br>
<div class=row>
<br>
<div class='column left previous'>
<br>
[{{< fa solid arrow-left >}} Lab#SE3-3: Library/Book, Expand Model](/javase/selab3-3.qmd)
<br>
</div>
<br>
<div class='column center'>
<br>
[{{< fa solid arrow-up >}} top](#top)
<br>
</div>
<br>
<div class='column right next'>
<br>
[Java Resources {{< fa solid arrow-right >}}](/javase/resources.qmd)
<br>
</div>
<br>
</div>
