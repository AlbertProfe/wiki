---
title: "Lab#RE02-1: Router & Hooks"
subtitle: ReactJS labs, Router & Hooks
author: albertprofe
date: "06/01/2021"
date-modified: last-modified
date-format: full
description: React JS Labs
categories: [reactjs, lab]
toc: true
number-sections: true
format:
  html
---


::: {.labs}
ðŸ“˜ **React JS Lab#RE02-1: Router & Hooks**

In this lab, we will be using:

- the ``react-router-dom``, which is a package with bindings for using React Router in web applications.
- We will use the ``Axios`` library to make HTTP requests to the API and retrieve the data in JSON format.
- hooks: `useState`, `useEffect`, `useReducer`.


The lab will demonstrate **how to use a ``react-router-dom`` with React to build a functional web application**.
:::

</br>

Reference: [codesandbox React Project to-do-11](https://codesandbox.io/s/to-do-11-hh9efc?file=/src/index.js){.external}

## Install `react-router-dom`

From: [npm pacakge](https://www.npmjs.com/package/react-router-dom){.external} and [react router](/reactjs/reactjs-app-router.qmd)

```js
npm i react-router-dom
```

> React Router enables "client side routing".

In traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server. When the user clicks a link, it starts the process all over again for a new page.

[Client side routing allows](https://reactrouter.com/en/main/start/overview){.external} your app to **update the URL from a link click without making another request for another document from the server.**

Instead, your app can immediately render some new UI and make data requests with fetch to update the page with new information.

[Main Concepts](https://reactrouter.com/en/main/start/concepts){.external}

::: {.callout-note}
## SPA vs MultiPage
A **Single Page Application (SPA)** is a web application that loads a single HTML page and dynamically updates the content as the user interacts with the application. The user interface is designed to provide a seamless experience, without the need for page refreshes.

In contrast, a **Multi-Page Application (MPA)** consists of multiple pages, each with its own HTML file, that are loaded separately when the user navigates to a different page. Each page typically has its own styles and scripts, which can result in longer load times and a less seamless user experience compared to SPAs.
:::

## Tree-folder & routes

![](/images/reactjs/lab-re-2-1.png){}

We use `React Router DOM` library to create a web application with multiple pages.

The import statement at the top imports several components from the `React Router DOM `library, including `BrowserRouter`, `Routes`, `Route`, and `Link`. 

> These components are used **to define the routes and navigation** for the application.

> The `Layout`, `Home`, `People`, `Contact`, and `NoPage` components are defined in separate files and imported at the top of the code.

::: {.column-margin}
The App component is the main component of the application and is exported as the default component. This component returns JSX, which is a syntax extension to JavaScript used to describe how the user interface should look like.
:::


The `<BrowserRouter>` component wraps the `<Routes>` component, indicating that this is the root of the application's routing system.

Within the `<Routes>` component, there is a single `<Route>` component that has a path attribute set to "/". This means that any URL that matches the root of the application will render this component.

The `<Route>` component with the path attribute set to "/" has four nested `<Route>` components inside it, each with a different path attribute and element attribute that points to the component that should be rendered when the corresponding URL is accessed.

- The first nested `<Route>` component has an index attribute, which means it will be rendered when the root URL is accessed. This component renders the Home component.
- The second nested `<Route>` component has a path attribute set to "/people", which means it will be rendered when the URL ends with "/people". This component renders the People component.
- The third nested `<Route>` component has a path attribute set to "/contact", which means it will be rendered when the URL ends with "/contact". This component renders the Contact component.
- The fourth and final nested `<Route>` component has a path attribute set to "*" which means it will be rendered when none of the other routes are matched. This component renders the NoPage component, indicating that the page the user is looking for cannot be found.


`Route`:

```js
import { BrowserRouter, Routes, Route } from "react-router-dom";
import Layout from "./route/Layout.jsx";
import Home from "./pages/home/Home.jsx";
import People from "./pages/people/People.jsx";
import Contact from "./pages/contact/Contact.jsx";
import NoPage from "./route/NoPage";

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Layout />}>
          <Route index element={<Home />} />
          <Route path="people" element={<People />} />
          <Route path="contact" element={<Contact />} />
          <Route path="*" element={<NoPage />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

`Layout`, in this particular case we **stack** all components:

```js
import { Outlet, Link } from "react-router-dom";
import React from "react";
import Footer from "./Footer";

export default function Layout() {
  return (
    <>
      <nav>
        <Link to="/">Home</Link>
        <span>|</span>
        <Link to="/people">People</Link>
        <span>|</span>
        <Link to="/contact">Contact</Link>
        <span>|</span>
      </nav>
      <Outlet />
      <Footer />
    </>
  );
}

```

::: {.column-margin}
![](/images/reactjs/lab-re-2-2.png){}
:::

## `useReducer`user profile form

Reference:

- [codesandbox with handlers functions](https://codesandbox.io/s/usereducer-example-form-nuyyyi?file=/App.js){.external}
- [codesandbox dispatcher onChange, onClick](https://codesandbox.io/s/usereducer-example-form-v2-pbj3kh?file=/App.js){.external}
- [React reference manual](https://react.dev/reference/react/useReducer#usage){.external}

### Create `route`

To add a `PersonForm` or `Form` component to a new route:

- first import the `PersonForm` **component**.
- Then, add a new **Route** element under the Layout Route element with a path of "person-form" and an element prop with the `PersonForm` component.
- Finally, update the `Layout` component to render a **Link** component to the new route.


### `reducer`

This new feature on Hola5 defines a **React component called "Form"** that allows users to modify and display a person's profile information. It uses the `useReducer` hook **to manage the component's state, which is initialized with an object** that contains the person's name, surname, and age.

```js
{   
  name: "Taylor",
  surname: "Feels",
  age: 42
}
```

> The **"reducer"** function defines **how state should be updated based on different types of actions dispatched by the component.** The actions include **incrementing** or **decrementing** the person's age and **changing** their name or surname.

![Basic structure component](/images/reactjs/lab-re-2-4.png){width="80%"}

The component's state is initialized with an object **(1)**

The component renders a form with input fields for the person's name and surname and buttons to increment or decrement their age. It also displays the current values of the person's name, surname, and age.

When the user interacts with the form elements **(5)**, the component dispatches **(3)** the appropriate action to the reducer function **(4)**, which updates the state and causes the component to re-render with the updated values **(5)**.


Reducer:

```js
function reducer(state, action) {

  switch (action.type) {

    case "incremented_age": {
      return {
        name: state.name,
        surname: state.surname,
        age: state.age + 1
      };
    }
    case "decremented_age": {
      return {
        name: state.name,
        surname: state.initialsurname,
        age: state.age - 1
      };
    }
    case "changed_name": {
      return {
        name: action.nextName,
        surname: state.surname,
        age: state.age
      };
    }
    case "changed_surname": {
      return {
        name: state.name,
        surname: action.nextSurName,
        age: state.age
      };
    }

    default: {
      throw Error("Unknown action: " + action.type);
    }
  }
}

```
::: {.column-margin}
![render reducer](/images/reactjs/lab-re-2-3.png){width="80%"}
:::

With or without handlers functions? Best without:

```js
export default function Form() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <>
      <h1> Person Profile form</h1>
      <hr /><br />
      <h3> Modify data</h3>

      <label>Name</label>
      <input
        value={state.name}
        onChange={(e) =>
          dispatch({
            type: "changed_name",
            nextName: e.target.value
          })
        }
      />

      <label>Surame</label>
      <input
        value={state.surname}
        onChange={(e) =>
          dispatch({
            type: "changed_surname",
            nextSurName: e.target.value
          })
        }
      />

      <button onClick={() => dispatch({ type: "incremented_age" })}>
        Increment age
      </button>

      <button onClick={() => dispatch({ type: "decremented_age" })}>
        Decrement age
      </button>
      <br /> <br /> <br />

      <h3>Person Profile</h3>
      <p><strong>Name:</strong> {state.name}</p>
      <p><strong>Surname:</strong> {state.surname}</p>
      <p><strong>Age:</strong> {state.age}</p>
    </>
  );
}
```
With handlers, perhaps a more verboise option:

```js
export default function Form() {
  const [state, dispatch] = useReducer(reducer, initialState);

  function handleButtonClickIncrement() {
    dispatch({ type: "incremented_age" });
  }

  function handleButtonClickDecrement() {
    dispatch({ type: "decremented_age" });
  }

  function handleInputChangeName(e) {
    dispatch({
      type: "changed_name",
      nextName: e.target.value
    });
  }

  function handleInputChangeSurName(e) {
    dispatch({
      type: "changed_surname",
      nextSurName: e.target.value
    });
  }

  return (
    <>
      <h1> Person Profile form</h1>
      <hr />
      <br />
      <h3> Modify data</h3>

      <label>Name</label>{" "}
      <input value={state.name} 
      onChange={handleInputChangeName} />

      <label> Surame </label>
      <input value={state.surname} 
      onChange={handleInputChangeSurName} />

      <button onClick={handleButtonClickIncrement}>
      Increment age</button>

      <button onClick={handleButtonClickDecrement}>
      Decrement age</button>
      
      <br /> <br /> <br />
      <h3>Person Profile</h3>
      <p>
        <strong>Name:</strong> {state.name}
      </p>
      <p>
        <strong>Surname:</strong> {state.surname}
      </p>
      <p>
        <strong>Age:</strong> {state.age}
      </p>
    </>
  );
}
```

## `useReducer`, `useEffect`, `useRef` clock

Reference: [codesandbox](https://codesandbox.io/s/usereducer-example-clock-11y79d?file=/App.js){.external} 

This component creates a simple stopwatch with three buttons: `Start`, `Stop`, and `Reset`.

The state of the stopwatch is managed using the `useReducer` hook, which takes in a reducer function and an initial state.

The `reducer` function is responsible for updating the state based on actions dispatched by the buttons. The initial state includes two properties, `isRunning` and time, which are set to false and 0 respectively.

The `useEffect` hook is used to start and stop the stopwatch. When the `isRunning` state is true, a timer is started using setInterval that dispatches a tick action every second. When `isRunning` state is false, the timer is cleared using `clearInterval`.

The `idRef` is a reference to the timer, and it is updated every time the `useEffect` hook is called.

The return statement returns a `JSX` template that displays the stopwatch: there are three buttons: "`Start`", "`Stop`", and "`Reset`" that dispatch start, stop, and reset actions respectively.



## Versions

 Code Version | Commit | Folder-Tree | Screeshoots |
| -- | -- | -- | -- |
| Hola5 0.0 | create project with route: [hola5 0.0](https://github.com/AlbertProfe/CifoJava2023-2/tree/2404dbaad80566fe038a01e14e910a125089dc08/hola5){.external} | [initial tree-folder](/images/reactjs/lab-re-2-1.png){width="60%"} | [render home](/images/reactjs/lab-re-2-2.png){width="80%"} |
| Hola5 0.1 | useReducer: user Profile [hola5 0.1](https://github.com/AlbertProfe/CifoJava2023-2/tree/aa824232395113d08efd6a86af38ebbc2a1e1e14/hola5){.external} </br> compoonent useReducer on [codesandbox with handlers functions](https://codesandbox.io/s/usereducer-example-form-nuyyyi?file=/App.js){.external} </br> or [codesandbox dispatcher onChange, onClick](https://codesandbox.io/s/usereducer-example-form-v2-pbj3kh?file=/App.js){.external} | [userReducer tree-folder](/images/reactjs/lab-re-2-6.png){width="60%"} | [render user profile](/images/reactjs/lab-re-2-5.png){width="80%"} |
| Hola5 0.2 | useReducer, userRef, useEffect: clock [hola5 0.2](){.external} </br> compoonent clock on [codesandbox](https://codesandbox.io/s/usereducer-example-clock-11y79d?file=/App.js){.external} </br>  | [clock tree-folder](/images/reactjs/lab-re-2-6.png){width="60%"} | [render clock](/images/reactjs/lab-re-2-5.png){width="80%"} |







<!--- navLinks -->
<br><br>
<div class=row>
<br>
<div class='column left previous'>
<br>
[{{< fa solid arrow-left >}} React JS: Lab#RE01-1](/reactjs/rjslab1.qmd)
<br>
</div>
<br>
<div class='column center'>
<br>
[{{< fa solid arrow-up >}} top](#top)
<br>
</div>
<br>
<div class='column right next'>
<br>
[React JS: Lab#RE03-1  {{< fa solid arrow-right >}}](/reactjs/rjslab3.qmd)
<br>
</div>
<br>
</div>
