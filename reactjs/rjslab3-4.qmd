---
title: "Lab#RE03-4: API Rest Domains"
subtitle: ReactJS labs
author: albertprofe
date: "06/01/2021"
date-modified: last-modified
date-format: full
description: labs
categories: [reactjs, lab, Lab#RE03]
toc: true
number-sections: true
format:
  html
---

::: {.labs}
üìò **React JS Lab#RE03-4:API Rest Domains"**

In this lab, we will be using:

- the ``react-router-dom``, which is a package with bindings for using React Router in web applications:
  - `decoupling` the communication layer by creating a separate service in React `JSX` and `JS`:
    - `service layer`: `TodoService.js`, api Rest Axios functions
    - `service layer`: `TodoContext.js`, creation of Context and repository of data and data-functions 
    - `UI components`: `todoApp.jsx` and its components to render the App.

:::

</br>

References:

- [useContext](/reactjs/reactjs-hook-context.qmd)
- [async](/reactjs/reactjs-app-async.qmd)
- ``todo`` refactored to domains:
  - component and sevice layer, [codesanbox todo-app-5-domain](https://codesandbox.io/s/todo-app-5-domain-7l18sb){.external}
- ``todo`` refactored to domains: 
  - three components and sevice layer, [codesanbox todo-app-6](https://codesandbox.io/s/todo-app-6-9q6lzy){.external}


## Approach

### Decoupling the communication layer
  
Decoupling the communication layer by creating a separate service in React JSX and JS architecture brings several benefits:

- `Separation of Concerns`: By creating a dedicated service layer, you separate the concerns of handling API communication and data manipulation from the components that render the UI. This promotes a cleaner and more maintainable codebase.
- `Reusability`: The service layer can be reused across multiple components or even in different parts of your application. By encapsulating API calls and data handling in a service, you can easily reuse the same logic without duplicating code.
- `Abstraction`: The service layer abstracts the details of API communication, such as HTTP requests and error handling, from the components. This abstraction simplifies the component code, making it more focused on rendering the UI and managing local state.
- `Testability`: Separating the communication layer as a service makes it easier to write unit tests. You can write tests specifically for the service functions, mocking the API calls and asserting the expected behavior, without the need to render the entire component hierarchy.
- `Maintainable and Scalable`: By centralizing the API communication logic in a service, it becomes easier to manage and update as your application grows. If the API changes or new features are added, you only need to update the service layer without affecting the components.

### `mutable` & `immutable`

 ![[codesanbox todo-app-6](https://codesandbox.io/s/todo-app-6-9q6lzy){.external} folder-tree to decouple the communication-layer](/images/reactjs/lab-re-3-16.png){width="40%"}

Regarding the separation of `mutable` and `immutable` code:

- The `service layer` (`TodoService.js`) handles mutable code related to **API requests and updates the server-side data**.
  -  It performs actions like creating, updating, and deleting todos by interacting with the server.
- The component layer, specifically the `TodoContext.js` and `UI components`, deals with `immutable` code.
  - It manages the **local state,** such as the list of todos, and provides an interface for components to interact with the service layer.
  - The components use the provided functions to update the state or **trigger API calls when necessary.**

### Context API

::: {.callout-note}
## React API Context
React API Context provides a way to share data across the component tree without passing props explicitly at each level. It allows you to create a context object that can be accessed by components nested within a Provider component. Context is primarily used for managing immutable data and state.
:::

The context itself is `immutable` because it provides a fixed value that can't be modified directly. The data or **state** it holds should be treated as `immutable` to <mark>maintain the unidirectional data flow and ensure predictable updates.</mark>

::: {.column-margin}
However, the components consuming the context can read the data from the context and use it to update their state or trigger actions. The components can then propagate the changes back to the context by using the provided functions or callbacks.
:::

::: {.callout-note}
## immutability
The concept of immutability is crucial in React as it helps ensure predictable rendering and state management. Immutable data allows for efficient change detection and can optimize rendering performance, as React can easily determine when to re-render components based on changes in immutable data.
:::

### Using React context

When using React context, it's important to follow best practices to make the most of this concept:

- `Define the context:` Create a context object using React.createContext(), providing an initial value. This value should typically be an immutable object or state.
- `Wrap components with the Provider`: Wrap the relevant components with the Provider component, passing the desired value as a prop. This will make the value accessible to the nested components.
- `Access the context value:` Components that need access to the context can consume it using either useContext or by wrapping the component with the Context.Consumer component.
- `Manage mutable state locally:` Components consuming the context can manage their own local state using useState, useReducer, or any other state management technique. They can update the state based on the context data and trigger actions accordingly.
- `Propagate changes back to the context:` If components need to update the context data or trigger actions that affect the context, they can use functions or callbacks provided by the context. These functions should handle the necessary updates and ensure immutability is maintained.


### fetching data: abort

If your [Effect fetches something](https://react.dev/learn/synchronizing-with-effects#fetching-data){.external}, the cleanup function should either [abort](https://developer.mozilla.org/en-US/docs/Web/API/AbortController){.external} the fetch or ignore its result:

![abort second trigger](/images/reactjs/lab-re-3-17.png){width="40%"}

> You can‚Äôt ‚Äúundo‚Äù a network request that already happened, but your cleanup function should ensure that the fetch that‚Äôs not relevant anymore does not keep affecting your application. If the userId changes from 'Alice' to 'Bob', cleanup ensures that the 'Alice' response is ignored even if it arrives after 'Bob'.

### `async`/`sync`: passing down `async` functions

![coupled UI components](/images/reactjs/lab-re-3-18.png){width="40%"}

Passing asynchronous functions as props <mark>can lead to some drawbacks and is generally not considered a good practice.</mark> Here are a few reasons why it's not recommended:

- `Prop Drilling`: If you pass asynchronous functions as props to deeply nested components, it requires you to propagate these props through each intermediate component. This leads to a concept known as "prop drilling," where components that do not directly need the asynchronous function still have to receive and pass it down. This can make your code more complex and harder to maintain.
- `Coupling Components`: By passing asynchronous functions as props, you tightly couple the components together. This means that if you decide to change the implementation of the asynchronous function or replace it with a different approach (e.g., using a different library, refactoring the code), you will have to update all the components that rely on that function. This can introduce unnecessary dependencies and make your codebase less flexible.
- `Code Duplication`: If multiple components require access to the same asynchronous function, passing it as a prop to each component results in code duplication. You'll need to repeat the prop declaration and handling in each component, leading to redundant code. This can make it more difficult to maintain and update the codebase.


#### using Context

::: {.callout-note}
Instead of passing ``asynchronous`` functions as props, <mark>using a shared context and provider pattern, such as React Context, allows you to decouple the components and provide a centralized location for managing and accessing shared state and functions.</mark>

By using a context, you can **avoid prop drilling** and provide a **clean and efficient** way to access the **asynchronous functions from any component within the context's scope.**
:::

- Additionally, using a ``provider`` and ``context`` pattern allows for better **separation of concerns**.
  - The ``provider`` handles the implementation details and provides the necessary functions, while the components consuming the context can focus on rendering and utilizing the shared data and functionality without worrying about how it is implemented or passed down through props.
- Using ``context`` allows you to create a **central place to manage and access the asynchronous function**, making it available to any component that needs it within the context's scope.
  - This avoids the need for **prop drilling**, where you would have to pass the function down through multiple levels of components as props.

::: {.callout-warning}
Propagating the asynchronous function via props can work, **but it may lead to some issues.**

Asynchronous operations like API requests typically have a delay in fetching data, and the results may not be available immediately.

If you pass the function as a prop and try to execute it synchronously within a component, you won't be able to wait for the response or handle any errors properly.

It can lead to unpredictable behavior and may cause the component to render with incomplete or incorrect data.
:::


By using ``context``, you can handle the ``asynchronous`` behavior appropriately, whether it's using async/await or promises, and ensure that the components consuming the context can work with the ``asynchronous`` function correctly.

## step-by-step todo api rest domains

 ![todo domains schema](/images/reactjs/todo-domains-schema.jpg){width="60%"}

## Versions

Code Version | Commit | Folder-Tree | Screeshoots |
| -- | -- | -- | -- |
| todoApp 0.4 | ToDoGrid decoupling with domains: [todoApp 0.4](){.external} | - | [render todoGrid](/images/reactjs/lab-re-3-7.png) - [todo created render](/images/reactjs/lab-re-3-8.png){width="80%"} |


<!--- navLinks -->
<br><br>
<div class=row>
<br>
<div class='column left previous'>
<br>
[{{< fa solid arrow-left >}} React JS: Lab#RE03-3](/reactjs/rjslab3-3.qmd)
<br>
</div>
<br>
<div class='column center'>
<br>
[{{< fa solid arrow-up >}} top](#top)
<br>
</div>
<br>
<div class='column right next'>
<br>
[React JS: Lab#RE03-5  {{< fa solid arrow-right >}}](/reactjs/rjslab3-5.qmd)
<br>
</div>
<br>
</div>
