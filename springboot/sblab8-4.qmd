---
title: "Lab#SB08-4: JPA"
subtitle: Spring Boot Restaurant Management JPA, Queries, Mappings and Relationships
author: albertprofe
date: "01/010/2024"
date-modified: last-modified
date-format: full
description:  Spring Boot
categories: [Spring-Boot, lab]
toc: true
number-sections: true
format:
    html
filters:
    - lightbox
lightbox: true
---

:::: {.labs}
ðŸ“˜ Spring Boot Lab#SB00-4: `RestaurantManager` JPA, Queries, Mappings and Relationships
## Summary

The Spring Boot `RestaurantManagement` System utilizes `JPA` to efficiently manage restaurant operations:

- Key entities include `Menu`, `MenuItem`, `Table`, `Order`, and `Customer`, with defined relationships such as one-to-many and many-to-many.
- The system employs repositories for database H2 access and services for business logic.
- Custom `queries` enhance data retrieval, enabling functionalities like fetching recent orders or customer-specific orders.

This architecture not only facilitates effective data management but also provides a robust foundation for building scalable restaurant applications, leveraging the power of Spring Boot and JPA for seamless integration and performance.
:::

</br>


- [Commits](https://github.com/AlbertProfe/restaurantManager/commits/master/){.external target='_blank'}

# RestaurantManager Project Summary

> Here's an introduction to Spring Boot Restaurant Management focusing on JPA, queries, mappings and relationships. This project demonstrates how to build a restaurant management system using Spring Boot and JPA. It covers key concepts like entity relationships, JPA mappings, and database queries.

**Key Components**

- **Entities**: Menu, MenuItem, Order, Customer
- **Repositories**: JpaRepository interfaces for database access
- **Services**: Business logic and database operations
- **Controllers**: REST API endpoints
- **Tests**: JUnit unitary tests for queries

**JPA Mappings**

The system uses the following JPA entity relationships:

- One-to-Many: Menu to MenuItems
- Many-to-One: Order to Customer
- Many-to-Many: Order to MenuItems


<details>
<summary>Example Menu entity:</summary>

```{.java .code-overflow-wrap filename="Menu.java"}

@Entity
public class Menu {

    @Id
    //@GeneratedValue
    private String id;

    private String name;

    @OneToMany(mappedBy = "menu", cascade = CascadeType.ALL)
    private List<MenuItem> items;

}
```
</details>

**Sample Queries**


<details>
<summary>Example Sample OrderRepository:</summary>

```{.java .code-overflow-wrap filename="Menu.java"}

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {

    List<Order> findByCustomer(Customer customer);

    @Query("SELECT o FROM Order o WHERE o.orderDate > :date")
    List<Order> findRecentOrders(@Param("date") LocalDate date);

}
```
</details>


**Key Relationships**

- Menu contains many MenuItems
- Order is placed by one Customer
- Order contains multiple MenuItems
- Customer can have multiple Orders

This structure allows for efficient querying and management of restaurant data using Spring Data JPA.


# UML

## `RestaurantManager` Relationships


1. **Inheritance:**
    - `TakeAwayOrder`, `ShippingOrderRestaurant`, and `EatInOrderRestaurant` all <mark>inherit</mark> from `OrderRestaurant`.

2. **One-to-Many/Many-to-One associations:**
    - One-to-Many
        - A `Customer` can have multiple `TakeAwayOrders`.
        - An `EatInOrderRestaurant` can be associated with multiple `TableRestaurants`.
        - A `Booking` can be associated with multiple `TableRestaurants`.
    - Many-to-One
        - Multiple `TakeAwayOrders` can be associated with a single `Customer`.
        - Multiple `Customers` can be associated with a single `Booking`.

3. **Many-to-Many associations:**
    - Many-to-Many
        - `OrderRestaurant` and `MenuRestaurant` have a many-to-many relationship.
        - `MenuRestaurant` and `MenuItemRestaurant` have a many-to-many relationship.
    - Many-to-Many with join table as entity
        - The relationship between `Customer` and `TableRestaurant` is effectively a many-to-many relationship, with `Booking` <mark>serving as a join table entity</mark>.
        - This is implemented as two one-to-many relationships:
            a. One `Customer` can have many `Bookings` (one-to-many)
            b. One `Booking` can have many `TableRestaurants` (one-to-many)
        - This structure allows for additional attributes on the `Booking` entity (such as date, time, etc.) while maintaining the many-to-many relationship between `Customer` and `TableRestaurant`.

::: {.column-margin}
This Lab#SB08-4 will implement this entities relationships:

![RestaurantManager UML](/images/springboot/labsb08/lab08-4-uml-2.png){.lightbox}

:::

```{mermaid}
classDiagram
direction LR
    class TableRestaurant {
        <<Entity>>
        -String name
        -String description
        -int qty
        -boolean busy
        -ArrayList<Booking> Bookings
        +toString()
    }
    
    class Customer {
        <<Entity>>
        -String id
        -String name
        -String email
        -String phoneNumber
        -int age
        -boolean vipCustomer
        -boolean deleted
        -ArrayList<Booking> Bookings
        +toString()
    }

    class Booking {
        <<Entity>>
        -String name
        -String phoneNumber
        -int peopleQty
        -LocalDateTime date
        -LocalDateTime SlotDate
        -String service
        -boolean confirmed
        -TableRestaurant tableRestaurant
        -Customer customer
        +toString()
    }

    Booking "n" *-- "1" TableRestaurant
    Customer  "1" --* "n" Booking

```




##  Updated UML

This is the updated UML from [Lab#SB08-1 UML and DDD](/springboot/sblab8-1.qmd#discussion-solving-uml){.external target='_blank'} correspond to this <mark>commit</mark>: [TestCreateOrder() with JPA, Customer 1:n TakeAwayOrder unidirectional relationship](https://github.com/AlbertProfe/restaurantManager/tree/51b172d69b9f04196dbd52d3abdf9c50a05a3ff9){.external target='_blank'}


::: {.column-page-right}

<details>
<summary>Updated UML from Lab#SB08-1 UML and DDD</summary>

```{mermaid}
classDiagram
    class OrderRestaurant {
        <<Entity>>
        -String id
        -Date date
        -String waiter
        -int peopleQty
        -double totalPayment
        -boolean paid
        -ArrayList<Menu> menus
        +toString()
    }
    class TakeAwayOrder {
        <<Entity>>
        -Customer customerTakeAway
        +toString()
    }
    class TableRestaurant {
        -String name
        -String description
        -int qty
        -boolean busy
        +toString()
    }
    class ShippingOrderRestaurant {
        -String address
        -String city
        -String riderName
        +toString()
    }
    class Customer {
        <<Entity>>
        -String id
        -String name
        -String email
        -String phoneNumber
        -int age
        -boolean vipCustomer
        -boolean deleted
    }
    class EatInOrderRestaurant {
        -ArrayList<TableRestaurant> tableRestaurants
        +toString()
    }
    class Menu {
        <<Serializable>>
        -String name
        -Double price
        -String content
        -boolean active
        -boolean water
    }
    class Booking {
        -String name
        -String phoneNumber
        -int peopleQty
        -LocalDateTime date
        -TableRestaurant tableRestaurant
        -boolean confirmed
        +toString()
    }

    OrderRestaurant <|-- TakeAwayOrder
    OrderRestaurant <|-- ShippingOrderRestaurant
    OrderRestaurant <|-- EatInOrderRestaurant
    OrderRestaurant "1" *-- "*" Menu
    TakeAwayOrder "*" -- "1" Customer
    EatInOrderRestaurant "1" *-- "*" TableRestaurant
    Booking "1" -- "1" TableRestaurant

```

</details>

:::

## UML with `MenuItemsRestaurant`

This UML would fit *almost* the final version (with `MenuItemsRestaurant`) of our project (without the @ManyToMany `Customer 1-n Booking n-1 TableRestaurant` relationship:

::: {.column-page-right}

<details>
<summary>UML without the Many-To-Many `Customer 1-n Booking n-1 TableRestaurant` relationship:
</summary>

```{mermaid}
classDiagram
    class OrderRestaurant {
        <<Entity>>
        -String id
        -Date date
        -String waiter
        -int peopleQty
        -double totalPayment
        -boolean paid
        -ArrayList<MenuRestaurant> menusRestaurant
        +toString()
    }
    class TakeAwayOrder {
        <<Entity>>
        -Customer customerTakeAway
        +toString()
    }
    class TableRestaurant {
        <<Entity>>
        -String name
        -String description
        -int qty
        -boolean busy
        -ArrayList<Booking> Bookings
        +toString()
    }
    class ShippingOrderRestaurant {
        <<Entity>>
        -String address
        -String city
        -String riderName
        +toString()
    }
    class Customer {
        <<Entity>>
        -String id
        -String name
        -String email
        -String phoneNumber
        -int age
        -boolean vipCustomer
        -boolean deleted
    }
    class EatInOrderRestaurant {
        <<Entity>>
        -ArrayList<TableRestaurant> tablesRestaurant
        +toString()
    }
    class MenuRestaurant {
        <<Entity>>
        -String name
        -Double price
        -String content
        -boolean active
        -boolean water
        -ArrayList<OrderRestaurant> ordersRestaurant
        -ArrayList<MenuItemRestaurant> MenusItemsRestaurant
    }
    class MenuItemRestaurant {
        <<Entity>>
        -String name
        -String content
        -boolean active
        -ArrayList<MenuRestaurant> MenusRestaurant
    }
    class Booking {
        <<Entity>>
        -String name
        -String phoneNumber
        -int peopleQty
        -LocalDateTime date
        -TableRestaurant tableRestaurant
        -boolean confirmed
        +toString()
    }

    OrderRestaurant <|-- TakeAwayOrder
    OrderRestaurant <|-- ShippingOrderRestaurant
    OrderRestaurant <|-- EatInOrderRestaurant
    OrderRestaurant "n" *--* "m" MenuRestaurant
    MenuRestaurant "n" *--* "m" MenuItemRestaurant
    TakeAwayOrder "n" *-- "1" Customer
    EatInOrderRestaurant "1" *-- "n" TableRestaurant
    Booking "1" *-- "n" TableRestaurant


```


</details>

:::

## UML with `ManyToMany` join table entity

With the Many-To-Many `Customer 1-n Booking n-1 TableRestaurant` relationship:

::: {.column-page-right}

<details>
<summary>UML with Many-To-Many `Customer 1-n Booking n-1 TableRestaurant` relationship:
</summary>


```{mermaid}
classDiagram
direction LR
    class OrderRestaurant {
        <<Entity>>
        -String id
        -Date date
        -String waiter
        -int peopleQty
        -double totalPayment
        -boolean paid
        -ArrayList<MenuRestaurant> menusRestaurant
        +toString()
    }

    class TakeAwayOrder {
        <<Entity>>
        -Customer customerTakeAway
        +toString()
    }

    class ShippingOrderRestaurant {
        <<Entity>>
        -String address
        -String city
        -String riderName
        +toString()
    }
    
    class EatInOrderRestaurant {
        <<Entity>>
        -ArrayList<TableRestaurant> tablesRestaurant
        +toString()
    }
    class MenuRestaurant {
        <<Entity>>
        -String name
        -Double price
        -String content
        -boolean active
        -boolean water
        -ArrayList<OrderRestaurant> ordersRestaurant
        -ArrayList<MenuItemRestaurant> MenusItemsRestaurant
    }
    class MenuItemRestaurant {
        <<Entity>>
        -String name
        -String content
        -boolean active
        -ArrayList<MenuRestaurant> MenusRestaurant
    }
    
    class Booking {
        <<Entity>>
        -String name
        -String phoneNumber
        -int peopleQty
        -LocalDateTime date
        -LocalDateTime BookingDate
        -String service
        -TableRestaurant tableRestaurant
        -boolean confirmed
        -Customer customer
        +toString()
    }

    class Customer {
        <<Entity>>
        -String id
        -String name
        -String email
        -String phoneNumber
        -int age
        -boolean vipCustomer
        -boolean deleted
        
    }

    class TableRestaurant {
        <<Entity>>
        -String name
        -String description
        -int qty
        -boolean busy
        -ArrayList<Booking> Bookings
        +toString()
    }

    OrderRestaurant <|-- TakeAwayOrder
    OrderRestaurant <|-- ShippingOrderRestaurant
    OrderRestaurant <|-- EatInOrderRestaurant
    OrderRestaurant "n" *--* "m" MenuRestaurant
    MenuRestaurant "n" *--* "m" MenuItemRestaurant
    TakeAwayOrder "n" *-- "1" Customer
    EatInOrderRestaurant "n" *-- "1" TableRestaurant
    Booking "n" *-- "1" TableRestaurant
    Customer  "1" --* "n" Booking

```

</details>

:::


# JPA Relationships


`JPA (Java Persistence API)` provides several types of relationships to <mark>model associations between entities </mark>:

1. **OneToOne**: Represents a single-valued association where an instance of one entity is related to a single instance of another entity.

2. **OneToMany**: Represents a multi-valued association where an instance of one entity can be related to multiple instances of another entity.

3. **ManyToOne**: The inverse of `OneToMany`, where multiple instances of an entity can be related to a single instance of another entity.

4. **ManyToMany**: Represents a multi-valued association where multiple instances of one entity can be related to multiple instances of another entity.

These relationships can be either `unidirectional` or `bidirectional`:

- **Unidirectional**: Only one entity has a reference to the other.
- **Bidirectional**: Both entities have references to each other.

> Relationships are typically annotated in entity classes using `@OneToOne`, `@OneToMany`, `@ManyToOne`, or `@ManyToMany`. Additional annotations like `@JoinColumn` and `mappedBy` are used to specify the joining strategy and the owning side of the relationship.



## OneToMany and ManyToOne


![Entity @oneToMany](/images/springboot/labsb08/labsb08-4-onetomay.png)

**`OneToMany` Unidirectional**

- One entity has a collection of another entity
- Only the *owning* side (the "One" side) has a reference to the other entity
- Example: One Department has many Employees

```java
@Entity
public class Department {
    @OneToMany
    private List<Employee> employees;
}

@Entity
public class Employee {
    // No reference to Department
}
```


**ManyToOne Unidirectional**


::: {.column-margin}
ManyToOne Unidirectional example:  [Order and Customer](https://github.com/AlbertProfe/restaurantManager/blob/51b172d69b9f04196dbd52d3abdf9c50a05a3ff9/src/test/java/dev/example/restaurantManager/TestsRelationshipsOrderRestaurant.java){.external target='_blank'}
:::


- Many entities are associated with one entity
- Only the **owning** side (the "Many" side) has a reference to the other entity
- Example: Many Employees belong to one Department

```java
@Entity
public class Employee {
    @ManyToOne
    private Department department;
}

@Entity
public class Department {
    // No reference to Employee
}
```


**Bidirectional Relationships**


::: {.column-margin}
Bidirectional Relationships example:

- [Library2: API Rest Author Book @OneToMany CRUD with Swagger](https://github.com/AlbertProfe/cifojava2022-3/wiki/Library2:-API-Rest-Author-Book-@OneToMany-CRUD-with-Swagger){.external target='_blank'}
- [TestCreateBookingTable() with JPA, TableRestaurant 1:n Booking bidirectional relationship](https://github.com/AlbertProfe/restaurantManager/tree/c562d8da650da2f758754312c0e1ecea2d8909af){.external target='_blank'}
:::

- Both entities have references to each other
- The "Many" side is usually the owning side
- Example: One Department has many Employees, and each Employee belongs to one Department

```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department")
    private List<Employee> employees;
}

@Entity
public class Employee {
    @ManyToOne
    private Department department;
}
```

> In bidirectional relationships, use `mappedBy` on the <mark>non-owning side to indicate the owning side's field name</mark>.


::: {.callout-note}
# Why Serialization is Needed?

**Serialization** is <mark>the process of converting an object or class into a byte stream</mark>. This byte stream can then be easily saved to a file, sent over a network, or stored in a database.

`Hibernate` uses serialization to <mark>create deep copies of entity objects</mark> for various purposes, such as **detached** entities, Session Management or **caching**.

For example: Collections within entities (like an `ArrayList<Menu> menus` within a `Order` entity ) are often **serialized** to store them efficiently in the database or to manage state changes.

Implementing `Serializable` is **not always the best solution**. In some cases, it might be better to adjust your entity relationships (`@OneToMany`) or use different mapping strategies (`@ElementCollection` for simple collections).

:::

### Casting

The [original](https://github.com/AlbertProfe/restaurantManager/blob/c562d8da650da2f758754312c0e1ecea2d8909af/src/test/java/dev/example/restaurantManager/RelationshipsOrderRestaurantTest.java#L80){.external target='_blank'} code avoids these issues by declaring orderToSave directly as TakeAwayOrder, eliminating the need for casting. This approach is generally preferred when possible, as it's safer and more straightforward.

::: {.column-page-right}

``` java
// Assume OrderRestaurant is a superclass of TakeAwayOrder
OrderRestaurant orderToSave = new TakeAwayOrder(
    "T11", new Date(), "Alice", 1, 10.99,
    true, new ArrayList<>(Arrays.asList(menu1)), null );

// We need to cast here
((TakeAwayOrder) orderToSave).setCustomerTakeAway(customer1);

// We might need to cast here too, depending on the repository's type parameter
takeAwayOrderRepository.save((TakeAwayOrder) orderToSave);
```
:::


- **Upcasting**: When we assigned a TakeAwayOrder object to an OrderRestaurant variable, we performed an implicit upcast. This is always safe because a TakeAwayOrder is an OrderRestaurant.
- **Downcasting**: When we cast orderToSave back to TakeAwayOrder, we're performing a downcast. This is potentially risky because not all OrderRestaurant objects are TakeAwayOrder objects.

::: {.callout-note}
# Why casting can be problematic?

- Type safety: Downcasting can lead to runtime errors if the object isn't actually of the type you're casting to.
- Code readability: Excessive casting can make code harder to read and understand.
- Performance: While minor, casting does involve a runtime check.


:::

## ManyToMany


**ManyToMany Unidirectional**

- Multiple entities are associated with multiple entities of another type
- Only one side has a reference to the other entity
- Example: Many Students can enroll in many Courses

```java
@Entity
public class Student {
    @ManyToMany
    @JoinTable(name = "STUDENT_COURSE",
        joinColumns = @JoinColumn(name = "STUDENT_ID"),
        inverseJoinColumns = @JoinColumn(name = "COURSE_ID"))
    private Set<Course> courses;
}

@Entity
public class Course {
    // No reference to Student
}
```

**ManyToMany Bidirectional**

- Both entities have references to each other
- One side is designated as the <mark>owning side, the other the inverse side</mark>
  - **Example**: Many Students can enroll in many Courses, and each Course can have many Students

```java
@Entity
public class Student {
    @ManyToMany
    @JoinTable(name = "STUDENT_COURSE",
        joinColumns = @JoinColumn(name = "STUDENT_ID"),
        inverseJoinColumns = @JoinColumn(name = "COURSE_ID"))
    private Set<Course> courses;
}

@Entity
public class Course {
    @ManyToMany(mappedBy = "COURSES")
    private Set<Student> students;
}
```

> In bidirectional ManyToMany relationships, use `mappedBy` on the non-owning side to indicate the owning side's field name. The `@JoinTable` annotation is used to specify the join table details.

::: {.callout-note}
# ManyToMany Considerations

- `ManyToMany` relationships often require a <mark>join table in the database</mark>
- Consider using an <mark>intermediate entity for complex relationships</mark> or when additional attributes are needed for the relationship
- Be cautious of **performance** implications with large datasets
:::


**ManyToMany with Join Table Entity**

Entity @ManyToMany with Join Table


- Represents a `many-to-many` relationship <mark>using an intermediate entity</mark>
- The `join table` becomes an **entity itself**, with two `one-to-many` relationships
- Provides more flexibility and allows additional attributes on the relationship
- **Example**: Students enrolled in Courses, with additional enrollment information

```java
@Entity
public class Student {
    @OneToMany(mappedBy = "student")
    private List<Enrollment> enrollments;
}

@Entity
public class Course {
    @OneToMany(mappedBy = "course")
    private List<Enrollment> enrollments;
}

@Entity
public class Enrollment {
    @ManyToOne
    private Student student;

    @ManyToOne
    private Course course;

    private LocalDate enrollmentDate;
    private String grade;
}
```

In this approach:

- The `Enrollment` entity serves as the join table
- It has two `@ManyToOne` relationships: one to `Student` and one to `Course`
- Additional fields like `enrollmentDate` and `grade` can be added to the `Enrollment` entity
- Both `Student` and `Course` have `@OneToMany` relationships to `Enrollment`
- The mappedBy attribute in @OneToMany indicates the owning side of the relationship

This structure allows for more detailed modeling of the relationship between students and courses, enabling the storage of relationship-specific data and easier querying of the association.

**Key Points**

This structure allows you to:

- Add additional fields to the relationship (e.g., enrollmentDate)
- Easily query the relationship from both sides
- Maintain better control over the lifecycle of the relationship


# Inherence and JPA

// to do

# Queries


// to do


# Code

- [Commits](https://github.com/AlbertProfe/restaurantManager/commits/master/){.external target='_blank'}

## commit `85a23ab`

- [manytomany menu n:m order](https://github.com/AlbertProfe/restaurantManager/tree/85a23abcf1d3e7a4818d7e374f2cbb1f81709371){.external target='_blank'}

![](/images/springboot/labsb08/85a23ab-1.png){.lightbox}

![](/images/springboot/labsb08/85a23ab-2.png){.lightbox}


> <mark>When iterating on a project and introducing new relationships</mark>, such as a **many-to-many** relationship between **orders** and **menus**, existing tests m**ay fail due to outdated assumptions and data setup**. In this case, the test `TestCreateOrder` needs to be updated to reflect the new relationship structure.

The main issue is that the test is creating `MenuRestaurant` objects in memory but not persisting them to the database. With a **many-to-many** relationship, both entities (**Order** and **Menu**) need to exist in the database before they can be associated.

To fix this, the test should be refactored to:

1. Save `MenuRestaurant` entities to the database using a repository before creating `orders`.
2. Fetch the saved `menus` from the database when creating `orders`.
3. Update the `order` creation process to use the new relationship structure.
4. Adjust `assertions` to verify the new relationship.

This **refactoring** ensures that the test <mark>accurately reflects the new data model and relationships</mark>.

It also helps maintain the integrity of the test suite as the project evolves, ensuring that tests remain valid and useful for catching potential issues in the updated codebase.

## commit `d65b4a9`

In this commit we update `TestCreateOrder()` to reflect the new relationship structure and create a new test.

- [TestCreateOrderMenu() and update TestCreateOrder()](https://github.com/AlbertProfe/restaurantManager/tree/d65b4a959ffe9b8d489e7ad0ef322b707482bb0c){.external target='_blank'}

<!--- navLinks -->
<br><br>
<div class=row>
<br>
<div class='column left previous'>
<br>
[{{< fa solid arrow-left >}} Lab#SB08-3: RestaurantManager ](/springboot/sblab8-3.qmd)
<br>
</div>
<br>
<div class='column center'>
<br>
[{{< fa solid arrow-up >}} top](#top)
<br>
</div>
<br>
<div class='column right next'>
<br>
[Lab#SB08-5: RestaurantManager  {{< fa solid arrow-right >}}](/springboot/sblab8-5.qmd)
<br>
</div>
<br>
</div>
